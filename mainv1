#include <Wire.h>

const int MPU_ADDR = 0x68;  // I2C address of MPU-6050 (ADO to GND)
const int LED_PIN  = LED_BUILTIN;  // Onboard LED (pin 13 on Uno)

void setup() {
  pinMode(LED_PIN, OUTPUT);

  Serial.begin(9600);
  Wire.begin();

  // Wake up MPU-6050 (it starts in sleep mode)
  Wire.beginTransmission(MPU_ADDR);
  Wire.write(0x6B);      // PWR_MGMT_1 register
  Wire.write(0);         // Set to 0 → wake up
  Wire.endTransmission(true);

  Serial.println("MPU-6050 initialised");
}

void loop() {
  // ----- Read accelerometer registers -----
  Wire.beginTransmission(MPU_ADDR);
  Wire.write(0x3B);              // Starting register for ACCEL_XOUT_H
  Wire.endTransmission(false);
  Wire.requestFrom(MPU_ADDR, 6, true);  // Read 6 bytes: AX, AY, AZ (high+low each)

  int16_t rawAx = (Wire.read() << 8) | Wire.read(); // ACCEL_XOUT_H, ACCEL_XOUT_L
  int16_t rawAy = (Wire.read() << 8) | Wire.read(); // ACCEL_YOUT_H, ACCEL_YOUT_L
  int16_t rawAz = (Wire.read() << 8) | Wire.read(); // ACCEL_ZOUT_H, ACCEL_ZOUT_L

  // ----- Convert to "g" units (assuming ±2g range → 16384 LSB/g) -----
  float ax = rawAx / 16384.0;
  float ay = rawAy / 16384.0;
  float az = rawAz / 16384.0;

  // ----- Compute tilt angle using accelerometer only -----
  // Here we'll use "pitch" based on X axis (you can swap if your board is mounted differently)
  // pitch is roughly the angle between board and gravity vector.
  float pitch = atan2(ax, sqrt(ay * ay + az * az)) * 180.0 / PI;  // in degrees

  // ----- Debug print -----
  Serial.print("ax: "); Serial.print(ax);
  Serial.print("  ay: "); Serial.print(ay);
  Serial.print("  az: "); Serial.print(az);
  Serial.print("  pitch: "); Serial.println(pitch);

  // ----- Threshold: turn LED on if |pitch| > 90° -----
  // In practice, you might see ~89.x rather than perfect 90, so you can use 80–85 if needed.
  const float TILT_THRESHOLD = 90.0;   // change this if you like

  if (abs(pitch) > TILT_THRESHOLD) {
    digitalWrite(LED_PIN, HIGH);
  } else {
    digitalWrite(LED_PIN, LOW);
  }

  delay(100);  // small delay to avoid spamming the bus / serial
}
